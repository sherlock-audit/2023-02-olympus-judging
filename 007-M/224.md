ak1

high

# SingleSidedLiquidityVault.sol : `_withdrawUpdateRewardState` is not updating the `cachedUserRewards` correctly.

## Summary
`_withdrawUpdateRewardState` is called during the `withdraw` call. Inside the `_withdrawUpdateRewardState`, `userRewardDebts` and `cachedUserRewards` are updated for both internal reward tokens and external reward tokens.
Also, user can claim if they want to claim the rewards. The unclaimed rewards are updated in `cachedUserRewards`. 
If user want to withdraw their with claim, any claimed rewards( userRewardDebts ) is subtracted from the `cachedUserRewards`. But in this case, `userRewardDebts` is nullified before subtracting from `cachedUserRewards`

## Vulnerability Detail

withdraw calls the `_withdrawUpdateRewardState`

    function withdraw(
        uint256 lpAmount_,
        uint256[] calldata minTokenAmounts_,
        bool claim_
    ) external onlyWhileActive nonReentrant returns (uint256) {
        // Liquidity vaults should always be built around a two token pool so we can assume
        // the array will always have two elements
        if (lpAmount_ == 0 || minTokenAmounts_[0] == 0 || minTokenAmounts_[1] == 0)
            revert LiquidityVault_InvalidParams();
        if (!_isPoolSafe()) revert LiquidityVault_PoolImbalanced();


        _withdrawUpdateRewardState(lpAmount_, claim_);


        totalLP -= lpAmount_;

inside the `_withdrawUpdateRewardState` both `cachedUserRewards` and `userRewardDebts` are updated for both internal as well as for external token.

    function _withdrawUpdateRewardState(uint256 lpAmount_, bool claim_) internal {
        uint256 numInternalRewardTokens = internalRewardTokens.length;
        uint256 numExternalRewardTokens = externalRewardTokens.length;


        // Handles accounting logic for internal and external rewards, harvests external rewards
        uint256[] memory accumulatedInternalRewards = _accumulateInternalRewards();
        uint256[] memory accumulatedExternalRewards = _accumulateExternalRewards();


        for (uint256 i; i < numInternalRewardTokens; ) {
            _updateInternalRewardState(i, accumulatedInternalRewards[i]);
            if (claim_) _claimInternalRewards(i);


            // Update reward debts so as to not understate the amount of rewards owed to the user, and push
            // any unclaimed rewards to the user's reward debt so that they can be claimed later
            InternalRewardToken memory rewardToken = internalRewardTokens[i];
            uint256 rewardDebtDiff = lpAmount_ * rewardToken.accumulatedRewardsPerShare;


            if (rewardDebtDiff > userRewardDebts[msg.sender][rewardToken.token]) {
                userRewardDebts[msg.sender][rewardToken.token] = 0;
                cachedUserRewards[msg.sender][rewardToken.token] +=
                    rewardDebtDiff -
                    userRewardDebts[msg.sender][rewardToken.token];
            } else {
                userRewardDebts[msg.sender][rewardToken.token] -= rewardDebtDiff;
            }


            unchecked {
                ++i;
            }
        }


        for (uint256 i; i < numExternalRewardTokens; ) {
            _updateExternalRewardState(i, accumulatedExternalRewards[i]);
            if (claim_) _claimExternalRewards(i);


            // Update reward debts so as to not understate the amount of rewards owed to the user, and push
            // any unclaimed rewards to the user's reward debt so that they can be claimed later
            ExternalRewardToken memory rewardToken = externalRewardTokens[i];
            uint256 rewardDebtDiff = lpAmount_ * rewardToken.accumulatedRewardsPerShare;


            if (rewardDebtDiff > userRewardDebts[msg.sender][rewardToken.token]) {
                userRewardDebts[msg.sender][rewardToken.token] = 0;
                cachedUserRewards[msg.sender][rewardToken.token] +=
                    rewardDebtDiff -
                    userRewardDebts[msg.sender][rewardToken.token];
            } else {
                userRewardDebts[msg.sender][rewardToken.token] -= rewardDebtDiff;
            }


            unchecked {
                ++i;
            }
        }
    }

at the following code block, the userRewardDebt is updated.
 
            if (rewardDebtDiff > userRewardDebts[msg.sender][rewardToken.token]) {
                userRewardDebts[msg.sender][rewardToken.token] = 0;
                cachedUserRewards[msg.sender][rewardToken.token] +=
                    rewardDebtDiff -
                    userRewardDebts[msg.sender][rewardToken.token];
            } else {
                userRewardDebts[msg.sender][rewardToken.token] -= rewardDebtDiff;

It is clear that the inside the if block, `userRewardDebts` is nullified before subtracting from `cachedUserRewards`

## Impact

Makes the reward calculation unstable.
Incorrectly updates the `cachedUserRewards` rewards. 

## Code Snippet

https://github.com/sherlock-audit/2023-02-olympus/blob/main/src/policies/lending/abstracts/SingleSidedLiquidityVault.sol#L566-L619

## Tool used

Manual Review

## Recommendation

subtract the `userRewardDebts` from  `cachedUserRewards` before setting to 0. 
